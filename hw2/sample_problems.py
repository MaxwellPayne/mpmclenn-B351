# Updated Sept 9, 2014
#
# Test cases for 8-puzzle search
# Relies on "makeState".
# 
# You can either use the test cases individually, or they're arranged
# into lists by group - you can "eval" each item in the list in turn
# and invoke your search function on the eval'd state.
# 
# The depth limits given are for optimal paths (such as you would get
# with breadth-first search but not necessarily depth-first).  They are
# theoretical upper limits for optimal paths.  The initial states were 
# generated by performing the given number of random moves from the 
# goal state, so it is possible that the actual optimal depth is much 
# less than indicated for a particular example.
import csv
import argparse
import os

from EightPuzzle import *
from mpmclenn_uninformed import *
from mpmclenn_informed import *

def outputTimes(solution_len, time_elapsed, outfile_name='output.txt'):
    with open(outfile_name, 'a') as outfile:
        writer = csv.writer(outfile)
        writer.writerow([solution_len, time_elapsed])

def testUninformedSearch(initialState, goalState, limit, timeit=False):
    searcher = UniformCostSolver(initialState, goal_state=goalState, limit=limit)
    if timeit:
        solution, time_elapsed = searcher.time_solution()
        outputTimes(len(solution), time_elapsed, outfile_name='uninformed.csv')
        return solution
    else:
        return searcher.solve()

def testInformedSearch(initialState, goalState, limit, timeit=False, heur_names=None):

    def sample_heuristic(current_node, goal_node):
        # Calculates how far each tile is from its goal state, and sums those distances
        current, goal = current_node.matrix, goal_node.matrix
        sum = 0
        for i in range(0, len(goal)):
            for j in range(0, len(goal)):
                tile = goal[i][j]
                for k in range(0, len(current)):
                    for l in range(0, len(current)):
                        if current[k][l] == tile:
                            sum += (k - i) * (k - i) + (j - l) * (j - l)
        return sum


    def hamming_distance(current_node, goal_node):
        dist = 0
        for current_tile, goal_tile in zip(current_node.state, goal_node.state):
            if current_tile != goal_tile:
                dist += 1
        
        return dist

    function_mapping = {'hamming': hamming_distance, 'sample': sample_heuristic}
    heuristics = (lambda c, g: 0,) if not heur_names else tuple((function_mapping[name] for name in heur_names))
    searcher = AstarSolver(initialState, goal_state=goalState, limit=limit, heuristic=heuristics)

    if timeit:
        solution, time_elapsed = searcher.time_solution()
        outfile_name = 'uninformed' if not heur_names else 'informed_' + '_'.join(sorted((name for name in heur_names)))
        outfile_name += '.csv'
        outputTimes(len(solution), time_elapsed, outfile_name=outfile_name)
        return solution
    else:
        return searcher.solve()

def _main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--use-heuristic', nargs='+', choices=('hamming', 'sample'), dest='heuristics')
    parser.add_argument('-t', action='store_true', dest='timeit', help='record runtime')
    args = parser.parse_args()

    goalState = makeState(1, 2, 3, 4, 5, 6, 7, 8, "blank")
    
    # First group of test cases - should have solutions with depth <= 5
    initialState1 = makeState(2, "blank", 3, 1, 5, 6, 4, 7, 8)
    initialState2 = makeState(1, 2, 3, "blank", 4, 6, 7, 5, 8)
    
    
    # Second group of test cases - should have solutions with depth <= 10
    initialState3 = makeState(2, 8, 3, 1, "blank", 5, 4, 7, 6)
    initialState4 = makeState(1, 2, 3, 4, 5, 6, "blank", 7, 8)


    # Third group of test cases - should have solutions with depth <= 20
    initialState5 = makeState("blank", 5, 3, 2, 1, 6, 4, 7, 8)
    initialState6 = makeState(5, 1, 3, 2, "blank", 6, 4, 7, 8)
    
    
    # Fourth group of test cases - should have solutions with depth <= 50
    initialState7 = makeState(2, 6, 5, 4, "blank", 3, 7, 1, 8)
    initialState8 = makeState(3, 6, "blank", 5, 7, 8, 2, 1, 4)

    TIMEIT = args.timeit

    if TIMEIT:
        open('output.txt', 'w').truncate()
        open('uninformed.csv', 'w').truncate()
        
        if 'hamming' in args.heuristics and 'sample' in args.heuristics:
            open('informed_hamming_sample.csv', 'w').truncate()
        elif 'hamming' in args.heuristics:
            open('informed_hamming.csv', 'w').truncate()
        elif 'sample' in args.heuristics:
            open('informed_sample.csv', 'w').truncate()

    print "Test 1 Uninformed %s" % \
        str(testUninformedSearch(initialState1, goalState, 10000000, timeit=TIMEIT))
    print "Test 2 Uninformed %s" % \
        str(testUninformedSearch(initialState2, goalState, 10000000, timeit=TIMEIT))
    print "Test 3 Uninformed %s" % \
        str(testUninformedSearch(initialState3, goalState, 10000000, timeit=TIMEIT))
    print "Test 4 Uninformed %s" % \
        str(testUninformedSearch(initialState4, goalState, 10000000, timeit=TIMEIT))
    print "Test 5 Uninformed %s" % \
        str(testUninformedSearch(initialState5, goalState, 10000000, timeit=TIMEIT))
    print "Test 6 Uninformed %s" % \
        str(testUninformedSearch(initialState6, goalState, 10000000, timeit=TIMEIT))
    print "Test 7 Uninformed %s" % \
        str(testUninformedSearch(initialState7, goalState, 10000000, timeit=TIMEIT))
    print "Test 8 Uninformed %s" % \
        str(testUninformedSearch(initialState8, goalState, 10000000, timeit=TIMEIT))

    #assert False

    print " "
    print " "
    print " "
    print " "
    print " "
    
    print "Test 1 Informed 1 %s" % \
        str(testInformedSearch(initialState1, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 2 Informed 1 %s" % \
        str(testInformedSearch(initialState2, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 3 Informed 1 %s" % \
        str(testInformedSearch(initialState3, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 4 Informed 1 %s" % \
        str(testInformedSearch(initialState4, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 5 Informed 1 %s" % \
        str(testInformedSearch(initialState5, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 6 Informed 1 %s" % \
        str(testInformedSearch(initialState6, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 7 Informed 1 %s" % \
        str(testInformedSearch(initialState7, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))
    print "Test 8 Informed 1 %s" % \
        str(testInformedSearch(initialState8, goalState, 10000000, timeit=TIMEIT, heur_names=args.heuristics))

if __name__ == '__main__':
    _main()
